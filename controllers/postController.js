
// * Import the Post model to interact with the 'posts' collection in MongoDB
const { url } = require("../config/cloudinary");
const Post = require("../models/Post");
const File = require("../models/File");

// * asyncHandler: wraps async route functions and automatically forwards errors to Express, so we don’t need try/catch blocks.
const asyncHandler = require("express-async-handler");
const { model } = require("mongoose");


//* Rendering post form
exports.getPostForm = asyncHandler( (req, res) => {

    // * Render the "newPost" EJS template when this route is accessed
    // * Pass data to the view:
    //   - title: sets the page title as "Create Post"
    //   - user: provides the logged-in user info (req.user) to the template
    res.render( "newPost", { title: "Create Post", user: req.user });

}
);


//! Creating a new post
// * asyncHandler automatically catches errors in async routes and forwards them to Express’s errorHandler, removing the need for try/catch blocks.
exports.createPost = asyncHandler( async (req, res) => {

    // * Extract the text fields (title, content) sent from the form submission
    const { title, content } = req.body;

    // * Validate that at least one file was uploaded (req.files is set by multer)
    if (!req.files || req.files.length === 0) {

        // * If no files, re-render the form with an error message for the user 
        // * NOTE: this returns early so the rest of the handler won't run
        return res.render("newPOst", {
            title: "Create Post",
            user: req.user,
            error: "At least one image is required",
        });

    }

    // * Process each uploaded image using Promise.all
    // * This allows parallel execution of async tasks for each file
    const images = await Promise.all( req.files.map(async (file) => {

            // * Create a new File document to store metadata about the uploaded image
            // * 'file.path'   = the Cloudinary URL (if using CloudinaryStorage)
            // * 'file.filename' = the public_id generated by Cloudinary
            const newFile = new File({
                url: file.path,              // * The URL to access this image
                public_id: file.filename,    // * Unique identifier in Cloudinary
                uploaded_by: req.user._id,   // * Tracks which user uploaded the image
            });

            // * Save the file record into the database
            await newFile.save();

            // * Return only the necessary details to attach to the Post model later
            return {
                url: newFile.url,
                public_id: newFile.public_id
            };

        })
    );


    // * Create a new Post document instance using the Post model
    // * We pass in all required fields:
    //   - title: comes from the form input
    //   - content: the blog post body text
    //   - author: the logged-in user (req.user._id)
    //   - images: array of uploaded image objects (url + public_id)
    const newPost = new Post({
        title,
        content,
        author: req.user._id,
        images,
    });

    // * Save the newly created post to the MongoDB database
    // * This returns a promise, so we await it
    await newPost.save();

    // * After saving successfully, re-render the newPost form
    // * We pass a success message so the user knows the post was created
    // * This success message can be shown on the EJS page
    res.render("newPost", {
        title: "Create Post",
        user: req.user,
        success: "Your blog post has been created successfully."
    });
}
);



//! Get All Posts
exports.getPosts = asyncHandler(async (req, res) => {

    // * Fetch all posts from the database
    // * .populate("author", "username") replaces the author ID with the actual user document
    // * but only selects the "username" field for efficiency
    const posts = await Post.find().populate("author", "username");

    // * Render the "posts" EJS template
    // * Pass the page title, posts data, and logged-in user details to the view
    res.render("posts", {
        title: "Posts",   // * Page title
        posts,            // * All fetched posts
        user: req.user,   // * Current logged-in user (if any)
    });

});



//! Get Post by ID
exports.getPostById = asyncHandler(async (req, res) => {
    
    // * Fetch a single post by its MongoDB ID from the route parameter
    // * First populate the 'author' field with only the username
    // * Then populate the 'comments' array, and inside each comment,
    // * populate the 'author' field with the username of the commenter
    const post = await Post.findById(req.params.id)
        .populate("author", "username")   // * Populate post author
        .populate({
            path: "comments",             // * Populate all comments of this post
            populate: {
                path: "author",           // * Inside each comment → populate comment's author
                model: "User",            // * Model used for comment author
                select: "username"        // * Select only the username
            }
        });
    

    // * Render the "post" EJS template
    // * Pass the page title, post data, and logged-in user details to the view
    res.render("postDetails", {
        title: "postDetails",   // * Page title
        post,            // * The fetched post
        user: req.user,  // * Current logged-in user (if any)
    });

});



//* Get Edit Post Form
exports.getEditPostForm = asyncHandler(async (req, res) => {

     // * Retrieve the post from MongoDB using the ID from the URL parameters
    const post = await Post.findById(req.params.id);

    // * If no post is found, render the post details page with an error message
    if (!post) {
        return res.render("postDetails", {
            title: "Post",          // * Page title
            post,                   // * Will be undefined or null
            user: req.user,         // * Logged-in user (if any)
            error: "Post not found" // * Error message displayed to the user
        });
    }

    // * Render the edit post form
    // * Pass the post data to pre-fill the form fields
    // * Pass the logged-in user for authorization logic in the view
    res.render("editPost", {
        title: "Edit Post", // * Page title
        post,               // * Post data to edit
        user: req.user,     // * Current logged-in user
    });

});